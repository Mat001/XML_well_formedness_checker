"""
    (SPHINX AUTOGENERATED DOC - FAILS FINDING xml_example.txt FILE !!!!!!! - FIX.)
    (htmldom is a nice xml/html parsing python code: source code is interesting-it's in downloads folder)

    TO DO:
D    - SEPARATE UTILITY FUNCTIONS INTO SEPARATE MODULE (for example get_clean_tags())
    - FIX FEW FUNCTIONS
    - DEFINE ORDER OF WHICH FUNCTIONS NEED TO EXECUTE FIRST. SOME FUNCTIONS DEPEND ON OTHERS TO BE DONE FIRST FOR THEM TO WORK.
    IMPORTANT!


    This project is a program to validate well-formedness of XML files.
    author: Matjaz Pirnovar

    Rules:
D    XML file must start with XML declaration.
        Example: <?xml version="1.0" encoding="UTF-8" standalone="no"?>
D   Must be only one root element and needs to have opening and closing tag.
D    Child elements (except XML declar. and !DOCTYPE (any others??)) need to be within the root element as its children.
D    Nested child elements need to be within their parents (elements must be properly nested).
D    Elements can have opening and closing tag AND can be single!
        <tag></tag>, <dd/>, <acb />, <child attribute="value" />
        (IMPORTANT - NOTE THIS LAST THREE SINGLE EMPTY TAGS - DON'T HAVE THEIR PAIRS!)
D    Single elements are empty and have forward slash before closing bracket.

D?    Element names must not contain spaces (<dateofbirth> is correct, <date of birth> is incorrect ).
D    Element names must not start with digits, diacritics, the full stop, the hyphen(minus) and 'xml' (any letter case).
D    Element names must start with letter (uppercase or lowercase), underscore, or colon.
D    Element names can contain colon, hyphen-minus, full stop (period), low line (underscore), and middle dot.
        Permitted: - W3schools xml validator doesn't allow to start with : or _  -strange!
            axiom
            _axiom_26
            :axiom_veintis√©is
            ora:open.source

            All of these names begin with a letter, an underscore, or a colon,
            followed by any combination of letters, digits, underscores, colons, and periods.
        Not permitted:

            #axiom
            @axiom
            26th_of_month
            axiom#26

            The first three begin with something other than a letter, underscore, or colon; the last starts out all right,
            but falls apart because the # is not a legitimate name character.

D    Must be no space between opening bracket and the name of an element.
D    Element names must be the same in opening and closing tag.
D    Elements must be closed properly: <child>Data</child>, <child attribute="value" />
D?   Tags are case sensitive.
D    Comments must be within comment tags <!-- -->.
D    Comments are not allowed to end with --->.
D    Matjaz: Comments (comment tags) must not be nested inside other comments.
D    Closing tags don't have attributes.



    Must allow multiple whitespace characters - define where!
    There may be whitespace between the end of the name or attribute in an opening element tag and the closing
    bracket of that element.
        Example: <body   > is allowed
    All data content must be within element tags (not inside tags). (how to chcek that???)

    Attributes must have both quotation marks around attribute's value.
    An attribute name must not appear more than once in the same start tag.
    Attribute values must not contain entity references to external entities.
    Single elements can contain attributes.
    '<' character is not allowed in attribute values. ('>' is allowed????)

    ----------------------------------
D?  SPECIAL CHARACTERS to escape in XML - should not appear in xml document content- must be escape with the following terms:
    CHECK IS THIS FOR NAMES OR DATA CONTENT?????
        "   &quot;
        '   &apos;
        <   &lt;
        >   &gt;
        &   &amp;

    (from w3.org) - for DATA CONTENT:
    The ampersand character (&) and the left angle bracket (<) MUST NOT appear in their literal form,
    except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
    If they are needed elsewhere, they MUST be escaped using either numeric character references or
    the strings " &amp; " and " &lt; " respectively. The right angle bracket (>) may be represented
    using the string " &gt; ", and MUST, for compatibility, be escaped using either " &gt; " or
    a character reference when it appears in the string " ]]> " in content, when that string
    is not marking the end of a CDATA section.

    ALSO SEE https://stackoverflow.com/questions/730133/invalid-characters-in-xml:
    The < MUST be escaped with a &lt; entity, since it is assumed to be the beginning of a tag.
    The & MUST be escaped with a &amp; entity, since it is assumed to be the beginning a entity reference
    The > should be escaped with &gt; entity. It is not mandatory -- it depends on the context -- but it is strongly advised to escape it.
    The ' should be escaped with a &apos; entity -- mandatory in attributes defined within single quotes but it is strongly advised to always escape it.
    The " should be escaped with a &quot; entity -- mandatory in attributes defined within double quotes but it is strongly advised to always escape it.
    ---------------------------------

    Data content must be within root element. Must not be outside of root element.
D    Data content must be in between any two > and < brackets.
        (Data content can be nested. It can appear like this:
            <tagA>
            aaa
                <tagB>bbb</tagB>
            </tagA>)

    MISC (for later):
    Doctype (DTD) declaration: <!DOCTYPE greeting SYSTEM "hello.dtd">
        Recommended doctype declarations: http://www.w3.org/QA/2002/04/valid-dtd-list.html
        Example why DTD is important:
            If you have created your own XML elements, attributes, and/or entities, then you should create a DTD.
            A DTD consists of a list of syntax definitions for each element in your XML document.
            When you create a DTD, you are creating the syntax rules for any XML document that uses the DTD.
            You are specifying which element names can be included in the document, the attributes that each
            element can have, whether or not these are required or optional, and more.
    Ensure CDATA applies (data is not parsed).
    CDATA sections may occur anywhere character data may occur (in between tags).

    Processing instructions (PI) should not start with 'xml'
    Referencing CSS example: <?xml-stylesheet type="text/css" href="tutorials.css"?>. Check that instead of href,
    a path to file can be used too
    Referencing scripts example: <script type="text/javascript">
    Referencing images
    Referencing links
    Referencing Schemas (XSD)
"""

from xml_well_formedness_check.utility_functions import *
import re


# ****************************************************************************************************
#   CHECK THAT NUMBER OF < and > IS EVEN
# ****************************************************************************************************

def number_of_angle_brackets_is_even():
    """
    Check that number of angle brackets (<,>) is even.
    PS: Not a full test of matching brackets! For example even number of closing brackets
    could be missing and the number would still be even.
    :return: sum of all angle brackets (as length of the list)
    """
    number_of_all_angle_brackets = len([char for char in getstring() if char == '<' or char == '>'])
    if number_of_all_angle_brackets % 2 != 0:
        print('No of angle brackets is not even: ', number_of_all_angle_brackets)
        return False
    else:
        return True

# ****************************************************************************************************
#   CHECK THAT NUMBER OF < and > MATCHES
# ****************************************************************************************************
def number_of_opening_and_closing_brackets_match():
    """
    Get number of opening and closing brackets and compare if the number matches.
    :return: boolean
    """
    open = getstring().count('<')
    clos = getstring().count('>')
    if not open == clos:
        print('Number of opening and closing brackets doesn\'t match. ' + str(open) + ' ' + str(clos))
        return False
    else:
        return True



# ****************************************************************************************************
#   CHECK THAT FILE STARTS WITH XML DECLARATION
# ****************************************************************************************************
def starts_with_xml_declaration():
    # if anything before '<?xml' check that that is a comment
    xml='<?xml'

    if not getstring().startswith(xml):
        #print('XML file immediately starts with XML declaration.')
        return False
    elif getstring()[:getstring().index(xml)].startswith('<!--')\
        and getstring()[:getstring().index(xml)].strip().endswith('-->'):
        #print("XML file starts with a comment(s) and then with XML declaration.")
        return True
    else:
        #print('XML file does not start with XML declaration.')
        return False



# ****************************************************************************************************
#   CHECK THAT XML FILE HAS TWO IDENTICAL NAMES FOR EACH ELEMENT (for OPENING AND CLOSING TAG)
# ****************************************************************************************************

def element_pair_has_strictly_identical_names():
    """
    More of a helper function. - DOESNT DEAL WITH SINGLE-ELEMENT TAGS - IF ANY CORRECT SINGLE ELEMENT TAGS ARE PRESENT RETURNS FALSE.
    SHOULD THAT BE OKAY, OR REDESIGN?
    Checks that all tag names, opening and closing have their corresponding pair.
    For example, there should not be three names for an element, but strictly two (opening and closing)
    :return: boolean True or False
    """
    # get occurences of each element
    occurences_each = [ get_clean_tags().count(i) for i in get_clean_tags() ]
    print(occurences_each)
    # exclude single elements
    [ occurences_each.remove(i) for i in occurences_each if i != 2 ]
    occurences_pairs = occurences_each
    if min(occurences_pairs) > 1 and max(occurences_pairs) < 3:
        return True
    else:
        return False



# ****************************************************************************************************
#   COMPARE OPENING AND CLOSING TAGS OF THE ROOT ELEMENT IF THEY MATCH
# ****************************************************************************************************

def root_tags_match():
    """ Compare opening and closing root element if they match.
    """
    # check if the names of the root tags match

    # clean opening and closing tag
    # inthis case it means: transform tuple ("<example id=''>", '</example>') into <example, <example)
    opening = get_root_element()[0] # get opening tag
    opening = opening.split()[0]    # ignore any attributes and closing bracket

    closing = get_root_element()[1].replace('/', '')    # get closing tag and ignore forward slash
    closing = closing.split('>')[0] # ignore closing bracket

    # now tags should be in clean form to be compared (eg <example, <example)
    if opening == closing:
        return True
    else:
        return False


# ****************************************************************************************************
#   DOES TAG HAVE A CORRECT ATTRIBUTE - CHECK, NEEDS FIXING?
# ****************************************************************************************************

def is_attribute_correctly_formed(tag):     # chnge this, to not having to enter a parameter
                                            # but instead function checks all attributes at once
    """
    Only checks if attribute is properly formed, not spaces before the atrribute name.
    """
    # POLISH - NEEDS DEFINE WELL WHAT ATTRIBUTE IS
    attribute = False
    # ALSO VALIDATE AGAINST THAT ATTRIBUTE HAS BOTH QUOTES, STARTING AND ENDING
    if ('\"' in tag and '=' in tag and tag.index('=') < tag.index('\"')): attribute = True
    if ('\'' in tag and '=' in tag and tag.index('=') < tag.index('\'')): attribute = True

    # get tags where tag name goes straight into equals sign without spaces - PUT IN IT'S OWN FUNCTION?????
    if ' ' not in tag and '=' in tag:
        print(tag, 'Equals sign can\'t be part of xml tag name.')
        attribute = False

    return attribute



# ****************************************************************************************************
#   CHECK THERE ARE NO SPACES IN TAG NAMES - NEEDS FIXING!!
#     MAYBE WRITE FROM SCRATCH, FUNCTION FOR INITIAL SPACE AND SPACES IN TAG NAMES ARE ALREADY DOING SIMILAR CHECK
#     SO WHAT NEEDS TO HAPPEN IN THIS FUNCTION THEREFORE?
# ****************************************************************************************************

def no_spaces_in_tag_names():   # no spaces in the first part of the term right after the <
    """
    # separate illegal tags with spaces from legal tags with attributes
    # it will be attribute if it contains at least equal sign or two quotes or both

    # it's an attribute if after compact term and after whitespace it has equal sign and/or quote(s)
    # to follow style: <term attribute="">

    # exclude closing tags with space
    # function exits as soon as it hits the first tag with illegal space (doesn't do remaining tags)
    """

    # get all tags that have at least one whitespace
    tags_spaces = [tag for tag in get_all_tags_in_order() if ' ' in tag[1:]]
    # print(tags_spaces)

    # for cases if there is "space-term-space" between name and attribute
    for t in tags_spaces:
        l=t.split()
        #print(l)

        for i, y in enumerate(l):
            if '=' in y:
                if i == 1 and y.startswith('=') :
                    #print(i, t, 'Tag name goes into equals sign, becomes attribute name.')
                    return False

                # FIX THIS PART !!!!!!!!!!!!!!!!!!!!:
                # detects <to a b="111"> as error but doesn't okay <to b ="111">
                if i >= 2:
                    #print(i, t, 'One or more terms in between tag name and attribute name and therefore spaces.')
                    return False


    # some other checks for spaces
    for tag in tags_spaces:
        # check ? (depends on is_attribute_correctly_formed(tag) function)
        if not is_attribute_correctly_formed(tag):
            #print('Tag has spaces but it doesn\'t have an attribute')
            return False

    return True



# ****************************************************************************************************
#   CHECK THAT THERE IS NO SPACE BETWEEN AN OPENING BRACKET AND THE NAME OPENING TAGS
# ****************************************************************************************************
def no_initial_space_in_opening_tags():
    """
    Check there is no space between opening bracket and the name in opening tags
    :return: boolean
    """
    for tag in get_all_tags_in_order():
        if tag[1] == ' ':
            #print('Space immediatelly after \'<\' not allowed.', tag)
            return False
        else:
            return True



# ****************************************************************************************************
#   CHECK THAT THERE NO SPACE IN CLOSING TAGS
# ****************************************************************************************************
def no_spaces_in_closing_tags():
    """
    Check that closing tags don't have spaces. INCLUDE SINGLE EMPTY TAGS!!!
    :return: boolean
    """
    for tag in get_all_tags_in_order():
        if tag[1] == '/' and ' ' in tag[1:]:
            #print('Closing tag must not have spaces.', tag)
            return False
        else:
            return True


# ****************************************************************************************************
#   CHECK FOR INVALID CHARACTERS AT THE BEGINNING OF TAG NAME
# ****************************************************************************************************
def no_invalid_initial_characters_in_opening_tag():
    """
    Element names must not start with digits, diacritics, the full stop, the hyphen and 'xml' (any letter case).
    Element names must start with letter (uppercase or lowercase), underscore, or colon.
    :return: boolean
    """

    # Check that element names DO NOT start with digits, diacritics, the full stop,
    # the hyphen and 'xml' (any letter case).
    # I left diacritics requirement out for the moment
    invalid_start_characters = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ,
                                '.', '-', 'xml', 'XML', 'Xml', 'xMl', 'xmL', 'XMl', 'xML']

    for tag in get_all_tags_in_order():
        for char in invalid_start_characters:
            if tag[1] == char:
                print('Tag with invalid start character: ', tag)
                return False

    # Check that element names DO start with letter (uppercase or lowercase), underscore, or colon.
    for tag in get_all_tags_in_order():
        if tag[1] != '?' and tag[1] != '!':     #make sure that names starting with ? and ! pass through
            if tag[1].isalpha():
                return True
            elif tag[1] == '_':
                return True
            elif tag[1] == ':':
                return True
            else:
                print(tag)
                return False


# ****************************************************************************************************
#   CHECK THAT ELEMENT NAMES CONTAIN ONLY VALID CHARACTERS
# ****************************************************************************************************
def element_names_contain_only_valid_characters():
    """
    Rule 1:
    Name must begin with letter (uppercase or lowercase), underscore, or colon
    and CONTINUING with letters, digits, hyphens, underscores, colons, or full stops.
    Middle dot also allowed (unlikely to be seen in xml).
    (source: http://www.xml.com/pub/a/2001/07/25/namingparts.html and http://www.w3.org/TR/xml/#sec-well-formed)

    - Doesnt check initial character rules (already covered)
    - Doesn't check for spaces in names (already covered)
    :return:
    """

    if no_invalid_initial_characters_in_opening_tag() and no_initial_space_in_opening_tags():
        names = set(get_clean_tags())

        # if anything else but letters, digits, hyphens, underscores, colons or full stops in names return false
        for char in names:
            if not re.match(r'[ A-Za-z0-9_:.-]*$', char):
                print('Failed char: ', char)
                return False
        return True

    else:
        print('Invalid initial character or disallowed initial space in opening tag.')
        return False


# ****************************************************************************************************
#   CHECK THAT ELEMENTS ARE CLOSED PROPERLY (PAIRED ELEMENTS, NOT SINGLE ONES)
# ****************************************************************************************************
def elements_are_closed_properly():
    """
    Check that paired elements (not single ones) are closed properly.
    Based on the fact that number of < must match number of </.
    If it doesn't, then either < or </ are mis-formatted or are missing.
    :return:
    """
    # This is only a preliminary partial check -> fails when there is even number of missing brackets of the same type!
    # The rest of the code below must run for complete check
    if not number_of_angle_brackets_is_even():
        print('Elements not properly closed. Number of angle brackets is not even - tag(s) incorrectly formed.')
        return False

    if not number_of_opening_and_closing_brackets_match():
        return False

    else:
        # THIS IS SAME TEST FOR NUMBER OF OPENING AND CLOSING BRACKETS as in number_of_opening_and_closing_brackets_match() ?
        # WITH A DIFFERENCE THAT IT CHECKS FOR / IN CLOSING TAG!
        # REDSIGN AND US ONLY number_of_opening_and_closing_brackets_match() IF THE SAME RESULT!!!!!

        # get number of opening brackets
        opening = 0
        for tag in get_all_tags_in_order():
            if re.match(r'<[^?!/]*$', tag): # get all brackets that don't have ?, !, / from < until the end of the tag = opening tags
                opening += 1

        # get number of closing brackets
        ending = getstring().count('</')

        print('opening: ', opening)
        print('ending: ', ending)

        if opening == ending:
            return True
        else:
            print('Closing tags not formatted properly.')
            return False



# ****************************************************************************************************
#   CHECK THAT TAGS ARE CASE SENSITIVE - NEEDS FIXING. REWRITE???
# ****************************************************************************************************
def no_case_sensitive_tags():
    """
    BUG !!!!!!!!!!!!!!!!  : line not_matching = [ i for i in unique_pairs if clean[i[0]] != clean[i[1]] ].
    WHEN SPACE IS INSERTED INTO TAG NAMES LIST ABOVE GOES OUT OF RANGE.
    This is probably because I'm splitting on spaces. ANd each time whitespace splits a tag
    there is more elements in the list?

    Check that tags are case sensitive.

    # get all tags and clean them up
    # change cleaned list of tags to lowercase
    # create a list of tag pairs (list of lists)
    # remove duplicate pairs
    # remove any single tags (eg remaining unpairable tags, such as those for XML declaration or DTD)
    # make final comparison if pairs match. Returns a list of their indexes.
    # get textual version of mismatched elements, if any. - for informative/ printing purposes.
    # return True of number of mismatches is zero, False otherwise
    """

    # get all tags and clean them up
    clean = get_clean_tags()

    # change 'clean' list of tags to lowercase
    lowercase = [tag.lower() for tag in clean]

    # create a list of pairs (list of lists)
    pairs2 = []
    for count, tag in enumerate(lowercase):
        pairs1 = []
        for count2, tag2 in enumerate(lowercase):
        # if name occurs more than once, get their indexes
            if tag2 == tag:
                pairs1.append(count2)
        pairs2.append(pairs1)

    # remove duplicate pairs
    pairs2_set = set(tuple(x) for x in pairs2)
    unique_pairs = [list(x) for x in pairs2_set]

    # make final comparison if pairs match. Returns a list of indexes.
    not_matching = [ i for i in unique_pairs if clean[i[0]] != clean[i[1]] ]

    # get textual version of mismatched elements, if any. - for informative/ printing purposes.
    not_matching_text = [ (clean[i[0]], clean[i[1]]) for i in not_matching ]

    # return True of numberof mismatches in zero, False otherwise
    if not_matching == 0:
        print('All tag pairs have the same letter case. No mismatches.')
        return True
    else:
        print('Upper/lower case mismatch in ' + str(len(not_matching)) + ' elements: ' + str(not_matching_text))
        return False



# ****************************************************************************************************
#   CHECK THAT NESTING IS PROPER
# ****************************************************************************************************
def is_nesting_proper():
    """
    CHECK THAT NESTING IS PROPER

    Iterate through the list of cleaned, ordered tags
    If item is not in (initially empty) temp list, then append item
    else if item is the last element in the temp list, then pop it out
    else - if item doesn't match the last item in the temp list, then that item was incorrectly nested. we flag error.

    There must always be both parts of a tag-pair within a stretched element (parent).
    In the example below <to></to> is "stretched tag" -  tag that holds other elements.
    For example <to><from></from><lastname></lastname></to> is correct
    For example <to><from><lastname></lastname></to></from> is incorrect
    :return: boolean
    """
    tag_list = get_clean_tags()
    print('clean: ', tag_list)
    temp_list = []

    for item in tag_list:
        if item not in temp_list:
            temp_list.append(item)
        elif item == temp_list[-1]:
            temp_list.pop()
        else:
            print('Incorrectly nested tag is \'' +temp_list[-1] + '\'.')
            return False

    if len(temp_list) == 0:
        return True


# ****************************************************************************************************
#   TESTING COMMENT TAGS AND COMMENTS
# ****************************************************************************************************

"""
    Check that comment tags are formed correctly.
    Opening and closing bracket must be there, including the exclamation m. and all the dashes.

    TAKE INTO ACCOUNT:
    - what if one bracket is missing (add condition number_of_tags_must_be_even? - maybe two brackets are missing!)
    what if one of the dashes is missing, for example <!-   -->
    what if two, three of the dashes are missing
    what if one or two or three extra dashes are added
    what if exclamation mark is missing
    note that comments can encapsulate several lines with xml code in between
    note that if item has <!-- then the first closing bracket > should have --> doesn't apply
    because comments can have < > inside them

    Follow the rule that comments can have start and close tag just about anywhere in the xml
    as long as start and end tag complement each other and have proper syntax <!-- and -->.
    So only check that they are a pair and that proper syntax.
    Prevent this:
    <!--
    <!-- more xml -->
    -->

    # chack that all opening tags have format <!--
    # check that all closing tags have format -->
    # check that closing format ---> is not present
    # check that comment element is not nested within another comment element

    # check that for each opening there is a closing tag (even number of both - is that enough?)
    # every opening tag must be immediatelly followed by a closing tag -
    # that may prevent nesting - preceeding point!

    # check that and < and > inside comments don't intefere with opening and closing comment tags

    :return:
    """


# ****************************************************************************************************
#   IS NUMBER OF COMMENT TAGS EVEN
# ****************************************************************************************************
def is_number_of_comment_tags_even():
    """
    Check if number of commnt tags is even
    - utility function
    :return: boolean
    """
    if len(get_opening_comment_tag_positions() + get_closing_comment_tag_positions()) % 2 == 0:
        return True
    else:
        return False



# ****************************************************************************************************
#   CHECK THAT OPENING COMMENT TAG IS FOLLOWED BY CLOSING TAG
# ****************************************************************************************************
def is_comment_opening_tag_followed_by_closing_tag():
    """
    # TEST THAT EACH OPENING TAG IS FOLLOWED BY CLOSING TAG
    Sequence of comment tags must follow: opening-closing_opening_closing.
    Disallow two of the same one after the other. This will check for nesting.
    :return: boolean
    """
    if is_number_of_comment_tags_even():
        l=[]
        # append position of oneing tag then closing, then opening, then closing etc.
        # sequence must be strictly sorted in ascending order, otherwise this function test fails-False
        for i in range(len(get_opening_comment_tag_positions())):
            l.append(get_opening_comment_tag_positions()[i])
            l.append(get_closing_comment_tag_positions()[i])
        #print('SEQUENCE: ', l)
        if l == sorted(l):
            return True
        else:
            return False
    else:
        print('Number of comment tags is not even - wrong nesting.')
        return False



# ****************************************************************************************************
#   CHECK THAT COMMENT CLOSING TAGS DONT HAVE EXTRA DASH (--->)
# ****************************************************************************************************
def comment_closing_tags_dont_have_extra_dash():
    """
    Check that comment closing tags don't have extra dash (--->).
    :return: boolean
    """
    if '--->' in getstring():
        return False
    else:
        return True


# ****************************************************************************************************
#   CHECK THAT COMMENTS THAT ARE NOT SINGLE DON'T HAVE ATTRIBUTES
# ****************************************************************************************************
def closing_tags_that_are_not_single_dont_have_attributes():
    """
    Check that closing tags that are not single don't have attributes.
    Here the check is made on absence of spaces in closing tag.
    That automatically implies no attributes.
    :return: boolean
    """
    for tag in get_all_tags_in_order():
        if tag[1] == '/':
            if ' ' not in tag:
                return True
            else:
                return False


# ****************************************************************************************************
#   CHECK THAT SINGLE ELEMENTS ARE CORRECTLY FORMED - WITHOUT ATRIBUTE
# ****************************************************************************************************
def single_element_is_correctly_formed_without_attribute():
    """
    Check that single elements are correctly formed.
    Examples: <example/> <br       />, <acb />, <child attribute="value" />

    # Done so far:
    # Includes proper closure!
    # Not checking for space between name and / because it is allowed. It's for attributes, which still need to be checked.
    # checking that there is no space between / and >
    # first part of the tag <... is already checked because functions no_initial_space_in_opening_tags(), ... take car of it
    # closing tag /> is validated here - no space between / and >
    # in between it's okay to have space - for attribute - which still need to be checked
    :return: boolean
    """

    # test the correctness of the single tag (if '/' at the end before >)
    for tag in get_single_elements():
        if tag[-2:] == '/>':
            return True
        else:
            print('Problematic single element - not correctly formed: ', tag)
            return False


# ****************************************************************************************************
#   CHECK THAT SINGLE ELEMENTS ARE CORRECTLY FORMED - WITH ATRIBUTE
# ****************************************************************************************************
def single_element_is_correctly_formed_with_attribute():
    if single_element_is_correctly_formed_without_attribute():
        pass
    else:
        print('Single element is not correctly formed (not to do with attribute).')
        return False


# ****************************************************************************************************
#   CHECK THAT NO RESTRICTED CHARACTERS ARE PRESENT IN DATA CONTENT
# ****************************************************************************************************
def no_restricted_characters_in_content():
    """
    WARNING: DOESN'T YET HANDLE REPLACEMENTS WITH &quot; &apos; etc.

    Characters ", ', <, >, & must not appear in xml document content.
    They need to be replaced by:
        "   &quot;
        '   &apos;
        <   &lt;
        >   &gt;
        &   &amp;
    :return: boolean
    """
    # get content between tags (>  <)
    # check that it doesn't contain any of the above characters
    restricted = [ '\"', '\'', '<', '>', '&'  ]
    restricted_chars = [ char for char in get_data_content() for c in restricted if c in char ]
    if len(restricted_chars) != 0:
        # print(restricted_chars)
        return False
    else:
        return True








# ****************************************************************************************************
# ****************************************************************************************************
# ****************************************************************************************************
#   EXECUTE FUNCTIONS
# ****************************************************************************************************

# UTILITIES
print('All tags in order: ', get_all_tags_in_order())
print('Clean tags: ', get_clean_tags())
print('Root element: ', get_root_element())
print('Get comment opening tag positions: ', get_opening_comment_tag_positions())
print('Get comment closing tag positions: ', get_closing_comment_tag_positions())


# CHECKS
print('Number of angle brackets is even: ', number_of_angle_brackets_is_even())
print('Numbers of opening and closing brackets match: ', number_of_opening_and_closing_brackets_match())
print('Starts with xml declaration: ', starts_with_xml_declaration())
print('Two identical names for each element (excluding single elms):', element_pair_has_strictly_identical_names())
print('Root element tags match: ', root_tags_match())
print('No spaces in tag names: ', no_spaces_in_tag_names())
print('No invalid initial characters in opening tag: ', no_invalid_initial_characters_in_opening_tag())
print('No initial space in opening tags: ', no_initial_space_in_opening_tags())
print('Element names contain only valid characters: ', element_names_contain_only_valid_characters())
print('No spaces in closing tags:', no_spaces_in_closing_tags())
print('Elements are closed properly: ', elements_are_closed_properly())
print('Closing tags (not single) dont have attributes: ', closing_tags_that_are_not_single_dont_have_attributes())
#print('No case sensitive tags: ', no_case_sensitive_tags())
print('Does a tag have a correctly formed attribute:')
#for tag in get_all_tags_in_order():
    #print(tag, is_attribute_correctly_formed(tag))

print('Is nesting proper: ', is_nesting_proper())

print('Is number of comment tags even: ',  is_number_of_comment_tags_even())
print('Is opening tag for comments immediatelly followed by closing tag (means there is no nesting): ',
      is_comment_opening_tag_followed_by_closing_tag())
print('Comment closing tags dont have extra dash: ', comment_closing_tags_dont_have_extra_dash())

print('Get single elements: ', get_single_elements())
print('Single element is correctly formed (not considering attrib.): ', single_element_is_correctly_formed_without_attribute())

print('No restricted characters in content: ', no_restricted_characters_in_content())
























