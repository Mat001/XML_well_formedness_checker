"""
    (SPHINX AUTOGENERATED DOC - FAILS FINDING xml_example.txt FILE !!!!!!! - FIX.)

    This project is a program to validate well-formdness of XML files.
    author: Matjaz Pirnovar

    XML syntaxt rules to use in the program logic (official source: http://www.w3.org/TR/xml/#sec-well-formed):

    1. The first line in the document is the XML declaration should always be included.
    It defines the XML version of the document:<?xml version="1.0"?>

    2. Root element (the first element). Needs to have open and closing tag.
    - check that the root element exists and that it has opening and closing tag DONE
    - indicator of the root element could be < without question mark (<? is for XML declaration)

    3. Child elements need to be within the root element
    - check that child elements have parents

    4. Nested child elements need to be within their parents

    5. All XML elements need to have closing tag. DONE

    6. XML tags are case sensitive

    7. All elements must be properly nested

    8. Attribute values must always be quoted

    9. Comments must be within comment tags <!-- -->

    10. All data strings must be within element tags (not inside tags)

    11. XML must allow multiple whitespace characters.

    12. Must be no spaces in the name of an element (<dateofbirth> is correct, <date of birth> is incorrect )

    13. Must be no space between opening bracket and the name of an element.
    Example: < body> is prohibited

    14. There may be whitespace between the end of the name or attribute in an opening element tag and the closing bracket of that element.
    Example: <body   > is allowed
    It's because attributes can be put there.

    15. Characters to escape in XML - should not appear in xml document content- do flag error, except if replaced by char. entity reference:
        "   &quot;
        '   &apos;
        <   &lt;
        >   &gt;
        &   &amp;

    16. Number of < and > should be even. If odd, then not well formed. DONE

    17. Nothing but whitespace is allowed between > and < brackets (in between closing and opening tag)

    18. CLosing tags don't have attributes

    19. Disallowed initial characters for Names include digits, diacritics, the full stop and the hyphen.
    (http://www.w3.org/TR/xml/#sec-well-formed)
"""


def getstring():
    """
    put xml content from file into a string (also make sure you use try/except!)
    :return: xml_string
    """
    xml_string = ""
    with open('xml_example.txt', 'r') as f:
        for i in f:
            xml_string = xml_string + i
        return xml_string


# ****************************************************************************************************
#   CHECK THAT NUMBER OF < and > IS EVEN
# ****************************************************************************************************

def number_of_angle_brackets_is_even():
    """
    Check that number of angle brackets (<,>) is even.
    :return: sum of all angle brackets (as length of the list)
    """
    number_of_all_angle_brackets = len([char for char in getstring() if char == '<' or char == '>'])
    return number_of_all_angle_brackets

print('Number of angle brackets (even?): ', number_of_angle_brackets_is_even())


# ****************************************************************************************************
#   GET ALL TAGS
# ****************************************************************************************************

def get_all_tags_in_order():
    """
    Get all tags (opening, closing) in order of appearance top down
    Procedure:
    get positions of opening and closing brackets
    pair up tag positions into list of tuples
    get a list of all tags
    :return: list of tags in order (top down)
    """

    # get positions of opening and closing brackets
    opening_bracket_positions = [i for i, char in enumerate(getstring()) if char == '<']
    closing_bracket_positions = [i for i, char in enumerate(getstring()) if char == '>']

    # pair up tag positions into list of tuples
    zipped = zip(opening_bracket_positions, closing_bracket_positions)
    zipped = list(zipped)

    # get a list of all tags
    result = [ getstring()[i[0] : i[1]+1] for i in zipped ]
    return result

print('All tags in order: ', get_all_tags_in_order())



# ****************************************************************************************************
#   CHECK THAT XML FILE HAS TWO IDENTICAL NAMES FOR EACH ELEMENT (for OPENING AND CLOSING TAG)
# ****************************************************************************************************

def each_element_has_strictly_two_identical_names_for_each_tag():
    """
    More of a helper function.
    Checks that all tag names, opening and closing have their corresponding pair.
    For example, there should not be three names for an element, but strictly two (opening and closing)
    :return: boolean True or False
    """
    l = [ get_all_tags_in_order().count(i) for i in get_all_tags_in_order() ]
    if min(l) < 2 or max(l) > 2:
        return False
    else:
        return True

#print('Two identical names for each element:', each_element_has_strictly_two_identical_names_for_each_tag())


# ****************************************************************************************************
#   GET THE ROOT ELEMENT
# ****************************************************************************************************

# get the root element
def get_root_element():
    """
    Get the root element:
    Iterate through all tags (provided by get_all_tags_in_order() function )
    Get the first tag that doesn't have ? or ! after opening bracket
    Get the very last tag
    :return: root element tuple
    """
    root_opening, root_closing='', ''

    # get the first tag that doesn't have ? or ! after opening bracket
    for i, tag in enumerate(get_all_tags_in_order()):
        if not (tag.startswith('<?') or tag.startswith('<!')):
            root_opening = tag
            break

    # get the very last tag
    for i, tag in enumerate(get_all_tags_in_order()):
        if tag.endswith('>') and i+1 == len(get_all_tags_in_order()):
            root_closing = tag
            break

    return root_opening, root_closing

print('Root element: ', get_root_element())


# ****************************************************************************************************
#   COMPARE OPENING AND CLOSING TAGS OF THE ROOT ELEMENT IF THEY MATCH
# ****************************************************************************************************

def root_tags_match():
    """ Compare opening and closing root element if they match.
    """
    # check if the names of the root tags match
    # make sure that for comparison you ignore the forward slash
    opening = get_root_element()[0]
    closing = get_root_element()[1].replace('/', '')
    if opening == closing:
        return True
    else:
        return False

print('Root element tags match: ', root_tags_match())



# ****************************************************************************************************
#   DOES TAG HAVE A CORRECT ATTRIBUTE
# ****************************************************************************************************

def is_attribute_correct(tag):
    """
    Only checks if attribute is properly formed, not spaces before the atrribute name.
    """
    # POLISH - NEEDS DEFINE WELL WHAT ATTRIBUTE IS
    attribute = False
    if ('\"' in tag or '=' in tag): attribute = True
    if ('\"' in tag and '=' in tag): attribute = True

    # get tags where tag name goes straight into equls sign without spaces - PUT IN IT'S OWN FUNCTION?????
    if ' ' not in tag and '=' in tag:
        print(tag, 'Equals sign can\'t be part of xml tag name.')
        attribute = False

    return attribute


print('Does a tag have an attribute:')
for tag in get_all_tags_in_order():
    print(tag, is_attribute_correct(tag))

# ****************************************************************************************************
#   CHECK THERE ARE NO SPACES IN TAG NAMES
# ****************************************************************************************************

def no_spaces_in_tag_names():   # no spaces in the first part of the term right after the <
    """
    # separate illegal tags with spaces from legal tags with attributes
    # it will be attribute if it contains at least equal sign or two quotes or both

    # it's an attribute if after compact term and after whitespace it has equal sign and/or quote(s)
    # to follow style: <term attribute="">

    # exclude closing tags with space
    # function exits as soon as it hits the first tag with illegal space (doesn't do remaining tags)
    """

    # get all tags that have at least one whitespace
    tags_spaces = [tag for tag in get_all_tags_in_order() if ' ' in tag[1:]]
    # print(tags_spaces)

    # for cases if there is "space-term-space" between name and attribute
    for t in tags_spaces:
        l=t.split()
        print(l)

        for i, y in enumerate(l):
            if '=' in y:
                if i == 1 and y.startswith('=') :
                    print(i, t, 'Tag name goes into equals sign, becomes attribute name.')
                    return False

                # FIX THIS PART !!!!!!!!!!!!!!!!!!!!:
                # detects <to a b="111"> as error but doesn't okay <to b ="111">
                if i >= 2:
                    print(i, t, 'One or more terms in between tag name and attribute name and therefore spaces.')
                    return False


    # some other checks for spaces
    for tag in tags_spaces:
        if tag[1] == '/' and ' ' in tag[1:]:
            print('Closing tag must not have spaces.')
            return False

        elif tag[1] == ' ':
            print('First character in a tag must not be space.')
            return False

        elif not is_attribute_correct(tag):
            print('Tag has spaces but it doesn\'t have an attribute')
            return False

    return True

print('No spaces in tag names: ', no_spaces_in_tag_names())


# ****************************************************************************************************
#   CHECK THERE IS NO SPACE BETWEEN OPENING BRACKET AND TAG NAME
# ****************************************************************************************************



# ****************************************************************************************************
#   CHECK IF SEQUENCE OF OPENING ELEMENTS MATCHES THE SEQUENCE OF THE CLOSING ELEMENTS
# ****************************************************************************************************
"""
def check_names_in_opening_and_closing_tags_match():

    Compare name in opening tag to the name in corresponding closing tag

    ex:
    note, to, firstname, lastname, from, heading, body
    (order needs to match)
    note, to, firstname, lastname, from, heading, body
    :return:

    note
    to
    firstname
    firstname
    lastname
    lastname
    to
    from
    from
    heading
    heading
    body
    body
    note
    '''





def check_order_of_opening_tags_matches_order_of_closing_tags():
    '''
    Procedure example (breadth-first approach):
    Traverse through the all opening tags.
    Do the same for the closing tags.
    Orders need to match. -> all opening tags have correct closing tag
    ex:
    note, to, firstname, lastname, from, heading, body
    (equals)
    note, to, firstname, lastname, from, heading, body
    :return:
    '''


def check_nesting():
    '''
    Procedure example (depth-first approach):
    Traverse through the all opening tags.
    Do the same for the closing tags.
    Orders need to match. -> all opening tags have correct closing tag
    ex:
    note, to, firstname, lastname, from, heading, body
    (equals)
    note, to, firstname, lastname, from, heading, body
    :return:
    """
















