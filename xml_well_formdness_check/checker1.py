"""
    (SPHINX AUTOGENERATED DOC - FAILS FINDING xml_example.txt FILE !!!!!!! - FIX.)

    This project is a program to validate well-formdness of XML files.
    author: Matjaz Pirnovar

    XML syntaxt rules to use in the program logic:

    1. The first line in the document is the XML declaration should always be included.
    It defines the XML version of the document:<?xml version="1.0"?>

    2. Root element (the first element). Needs to have open and closing tag.
    - check that the root element exists and that it has opening and closing tag DONE
    - indicator of the root element could be < without question mark (<? is for XML declaration)

    3. Child elements need to be within the root element
    - check that child elements have parents

    4. Nested child elements need to be within their parents

    5. All XML elements need to have closing tag. DONE

    6. XML tags are case sensitive

    7. All elements must be properly nested

    8. Attribute values must always be quoted

    9. Comments must be within comment tags <!-- -->

    10. All data strings must be within element tags (not inside tags)

    11. XML must allow multiple whitespace characters.

    12. Must be no spaces in the name of an element (<dateofbirth> is correct, <date of birth> is incorrect )

    13. Must be no space between opening bracket and the name of an element.
    Example: < body> is prohibited

    14. There may be whitespace between the end of the name or attribute in an opening element tag and the closing bracket of that element.
    Example: <body   > is allowed
    It's because attributes can be put there.

    15. Characters to escape in XML - should not appear in xml document content- do flag error, except if replaced by char. entity reference:
        "   &quot;
        '   &apos;
        <   &lt;
        >   &gt;
        &   &amp;

    16. Number of < and > should be even. If odd, then not well formed. DONE

    17. Nothing but whitespace is allowed between > and < brackets (in between closing and opening tag)

"""


def getstring():
    '''
    put xml content from file into a string (also make sure you use try/except!)
    :return: xml_string
    '''
    xml_string = ""
    with open('xml_example.txt', 'r') as f:
        for i in f:
            xml_string = xml_string + i
        return xml_string


# ****************************************************************************************************
# GET THE OPENING ROOT ELEMENT
# ****************************************************************************************************

def root_element_opening():
    ''' Get the opening root element.

        Iterate from start of the file onwards.
        store position value when you hit first '<' character that is not part of XML declaration (no ? after '<')
        that is the opening tag of the root element
        WHAT ABOUT IF  '<' chars appear before the root tag '<'???? Then it doesn't work! How do I define root element and finf it???
    '''
    opening, closing = 0, 0
    flag = False
    for i, char in enumerate(getstring()):  # loop through tuple items and find the first item that has '<'.
        # CHECK THIS: HOW CAN ? and ! APPEAR AT THE SAME TIME. CHANGE and TO or?
        if char == '<' and getstring()[i + 1] != '?' and getstring()[i + 1] != '!':  # '!' is to ignore DTD declarations
            opening = i
            flag = True
        if char == '>' and flag == True:
            closing = i
            content = getstring()[opening:closing + 1]
            return content


print('result-opening: ', root_element_opening())



# ****************************************************************************************************
#   GET THE CLOSING ROOT ELEMENT
# ****************************************************************************************************

def root_element_closing():
    ''' Get the closing root element.
    '''
    for count, char in enumerate(
            reversed(getstring())):  # loop through tuple items and find the first item that has '<'.
        if char == '>':  # found last closing bracket in the whole file, function only as an assertion - no other mening
            assert count == 0
        if char == '<':  # iterate from the end and find first opening bracket
            opening = count + 1
            return getstring()[-opening:]  # return characters from last opening bracket to the end


print('result-closing: ', root_element_closing())



# ****************************************************************************************************
#   COMPARE OPENING AND CLOSING ROOT ELEMENTS IF THEY MATCH
# ****************************************************************************************************

def root_element_exists_and_matches():
    ''' Compare opening and closing root element if they match.
    '''
    # check if the names of the root tags match
    # make sure that for comparison you ignore the forward slash
    if root_element_opening() == (root_element_closing()[0] + root_element_closing()[2:]):
        print(root_element_opening(), root_element_closing(), "Root element: opening and closing tag match.")
    else:
        print(root_element_opening(), root_element_closing(), "Root element: opening and closing tag don't match.")


root_element_exists_and_matches()


# ****************************************************************************************************
#   CHECK THAT NUMBER OF < and > IS EVEN
# ****************************************************************************************************

def number_of_angle_brackets_is_even():
    '''
    Check that number of angle brackets (<,>) is even.
    :return: sum of all angle brackets (as length of the list)
    '''
    number_of_all_angle_brackets = len([char for char in getstring() if char == '<' or char == '>'])
    return number_of_all_angle_brackets


print('Number of angle brackets (even?): ', number_of_angle_brackets_is_even())


# ****************************************************************************************************
#   GET ALL TAG NAMES
# ****************************************************************************************************

def get_all_tags_in_order():
    '''
    Get all tags (opening, closing) in order of appearance top down
    Procedure:
    take tag names immediately following all '<'
    put them into a list (which is ordered by nature)
    do the same for the tag names after '</'
    :return: list of tags in order (top down)
    '''

    # get positions of opening and closing brackets
    opening_bracket_positions = [i for i, char in enumerate(getstring()) if char == '<']
    closing_bracket_positions = [i for i, char in enumerate(getstring()) if char == '>']

    # remove any xml declaration or schema tags from lists of positions
    temp = 0
    for i, char in enumerate(getstring()):
        if char == '<' and getstring()[i + 1] == '?':
            del(opening_bracket_positions[i])
            temp = i
        if char == '>' and getstring()[i - 1] == '?':
            del(closing_bracket_positions[temp])
        '''
        if char == '<' and getstring()[i + 1] == '!':
            temp=i
            del (opening_bracket_positions[i])
            del (closing_bracket_positions[temp])
        '''
    # check that number of elements in both tag lists is the same. Because one of them used in for loop below.
    assert len(opening_bracket_positions) == len(closing_bracket_positions)  # make sure they are the same length
    result_list=[]
    for i in range(len(opening_bracket_positions)):
        op = opening_bracket_positions[i]
        cl = closing_bracket_positions[i]
        result = getstring()[op + 1:cl]
        if result[0] == '/': result = result[1:]  # take out forward slash from the closing tag
        result_list.append(result)
    return result_list

print('All tags in order: ', get_all_tags_in_order())



# ****************************************************************************************************
#   CHECK THAT XML FILE HAS TWO IDENTICAL NAMES FOR EACH ELEMENT (for OPENING AND CLOSING TAG)
# ****************************************************************************************************

def each_element_has_strictly_two_identical_names_for_each_tag():
    '''
    More of a helper function.
    Checks that all tag names, opening and closing have their corresponding pair.
    For example, there should not be three names for an element, but strictly two (opening and closing)
    :return: boolean True or False
    '''
    l = [ get_all_tags_in_order().count(i) for i in get_all_tags_in_order() ]
    if min(l) < 2 or max(l) > 2:
        return False
    else:
        return True

print('Two identical names for each element:', each_element_has_strictly_two_identical_names_for_each_tag())



# ****************************************************************************************************
#   CHECK IF SEQUENCE OF OPENING ELEMENTS MATCHES THE SEQUENCE OF THE CLOSING ELEMENTS
# ****************************************************************************************************

def check_names_in_opening_and_closing_tags_match():
    '''
    Compare name in opening tag to the name in corresponding closing tag

    ex:
    note, to, firstname, lastname, from, heading, body
    (order needs to match)
    note, to, firstname, lastname, from, heading, body
    :return:

    note
    to
    firstname
    firstname
    lastname
    lastname
    to
    from
    from
    heading
    heading
    body
    body
    note
    '''





def check_order_of_opening_tags_matches_order_of_closing_tags():
    '''
    Procedure example (breadth-first approach):
    Traverse through the all opening tags.
    Do the same for the closing tags.
    Orders need to match. -> all opening tags have correct closing tag
    ex:
    note, to, firstname, lastname, from, heading, body
    (equals)
    note, to, firstname, lastname, from, heading, body
    :return:
    '''


def check_nesting():
    '''
    Procedure example (depth-first approach):
    Traverse through the all opening tags.
    Do the same for the closing tags.
    Orders need to match. -> all opening tags have correct closing tag
    ex:
    note, to, firstname, lastname, from, heading, body
    (equals)
    note, to, firstname, lastname, from, heading, body
    :return:
    '''
















